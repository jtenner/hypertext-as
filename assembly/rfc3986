import { AnyOfRule, AnyRule, ByteSink, EqualsRule, EveryRule, KeywordRule, ManyRule, OptionalRule, Range } from "byte-parse-as/assembly";

import { COLON } from "./util";
import { ALPHA, DIGIT, HEXDIG } from "./rfc5234";

export class URI {
  scheme: string | null = null;
  path: string | null = null;
  query: string | null = null;
  fragment: string | null = null;
}



// host          = IP-literal / IPv4address / reg-name
export const HOST = new AnyRule([IP_LITERAL, IPV4_ADDRESS, REG_NAME]);

// sub-delims    = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
export const SUB_DELIMS = new AnyOfRule("!$&'()*+,;=");

// pct-encoded   = "%" HEXDIG HEXDIG
export const PCT_ENCODED = new EveryRule([new EqualsRule(0x25), HEXDIG, HEXDIG]);

// UNRESERVED    = ALPHA / DIGIT / "-" / "." / "_" / "~"
export const UNRESERVED = new AnyRule([ALPHA, DIGIT, new AnyOfRule("-._~")]);

// userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
export const USERINFO = new OptionalRule(new ManyRule(new AnyRule([
  UNRESERVED,
  PCT_ENCODED,
  SUB_DELIMS,
  COLON,
])))

// authority     = [ userinfo "@" ] host [ ":" port ]
export const AUTHORITY = new EveryRule([
  new OptionalRule(new EveryRule([USERINFO, new EqualsRule(0x40)])),
  HOST,
  new OptionalRule(new EveryRule([COLON, PORT])),
]);

// HIER PART
// hier-part     = "//" authority path-abempty
//                  / path-absolute
//                  / path-rootless
//                  / path-empty

export const HIER_PART = new AnyRule([
  new EveryRule([new KeywordRule("//"), AUTHORITY, PATH_ABEMPTY]),
  PATH_ABSOLUTE,
  PATH_ROOTLESS,
  PATH_EMPTY,
]);



// SCHEME
export const SCHEME = new EveryRule([
  ALPHA,
  new OptionalRule(new ManyRule(new AnyRule([
    ALPHA,
    DIGIT,
    new AnyOfRule("+-."),
  ])))
])

// URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
export function parse_uri(buffer: ByteSink, index: i32, range: Range, uri: URI): bool {
  let start = index;

  // SCHEME
  if (!SCHEME.test(buffer, index, range)) return false;
  uri.scheme = range.toString();
  index = range.end;

  // ":"
  if (!COLON.test(buffer, index, range)) return false;
  index++;

  // HIER_PART
  if (!HIER_PART.test(buffer, index, range)) return false;
  uri.path = range.toString();
  index = range.end;

  // query
  if (QUESTION.test(buffer, index, range)) {
    index++;
    if (parse_query(buffer, index, range)) {
      uri.query = range.toString();
      index = range.end;
    }
  }

  // fragment
  if (HASH.test(buffer, index, range)) {
    index++;
    if (parse_fragment(buffer, index, range)) {
      uri.fragment = range.toString();
    }
  }

  if (buffer.byteLength != index) return false;

  range.start = start;
  return true;
}
